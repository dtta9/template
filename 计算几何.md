# 计算几何

## 点类

### 基础模板

```c++
using T = double;
const T eps = 1e-8;
struct Point {
    T x;
    T y;
    Point(T x = 0, T y = 0) : x(x), y(y) {}
     
    Point &operator+=(const Point &p) {
        x += p.x, y += p.y;
        return *this;
    }
    Point &operator-=(const Point &p) {
        x -= p.x, y -= p.y;
        return *this;
    }
    Point &operator*=(const T &v) {
        x *= v, y *= v;
        return *this;
    }
    friend Point operator-(const Point &p) {
        return Point(-p.x, -p.y);
    }
    friend Point operator+(Point lhs, const Point &rhs) {
        return lhs += rhs;
    }
    friend Point operator-(Point lhs, const Point &rhs) {
        return lhs -= rhs;
    }
    friend Point operator*(Point lhs, const T &rhs) {
        return lhs *= rhs;
    }
    bool operator==(const Point a) const{
        return (fabs(x - a.x) <= eps && fabs(y - a.y) <= eps);
    }
};
typedef Point Vector;

int sign(T x){ // 符号函数
    if(fabs(x) < eps)
        return 0;
    if(x < 0)
        return -1;
    return 1;
}

int cmp(T x, T y){ // 比较函数
    if(fabs(x - y) < eps)
        return 0;
    if(x < y)
        return -1;
    return 1;
}
 
T dot(const Point &a, const Point &b){ // 点积 
    return a.x * b.x + a.y * b.y;
}
 
T cross(const Point &a, const Point &b){ // 叉积 
    return a.x * b.y - a.y * b.x;
}

T get_length(Point a){ // 求向量模长
    return sqrt(dot(a, a));
}

T get_angle(Point a, Point b){ // 求A->B的有向角
    return acos(dot(a, b) / get_length(a) / get_length(b));
}

T area(Point a, Point b, Point c){ // A为顶点，向量AB与向量AC的叉积，即三角形ABC的面积的2倍（有向）
    return cross(b - a, c - a);
}

Point rotate(Point a, T angle){ // 将向量A顺时针旋转angle度
    return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle) + a.y * cos(angle));
}

Point get_line_intersection(Point p, Vector v, Point q, Vector w){ // 两直线的交点
    // 使用前提，直线必须有交点
    // cross(v, w) == 0则两直线平行或者重合
    Vector u = p - q;
    T t = cross(w, u) / cross(v, w);
    return p + v * t;
}

T distance_to_line(Point p, Point a, Point b){ // 点到直线的距离，直线为AB所在直线
    Vector v1 = b - a, v2 = p - a;
    return fabs(cross(v1, v2) / get_length(v1));
}

T distance_to_segment(Point p, Point a, Point b){ // 点到线段的距离，线段为线段AB
    if (a == b)
        return get_length(p - a);

    Vector v1 = b - a, v2 = p - a, v3 = p - b;
    if (sign(dot(v1, v2)) < 0)
        return get_length(v2);
    if (sign(dot(v1, v3)) > 0)
        return get_length(v3);
    return distance_to_line(p, a, b);
}

Point get_line_projection(Point p, Point a, Point b){ // 点在直线上的投影，直线为AB所在直线
    Vector v = b - a;
    return a + v * (dot(v, p - a) / dot(v, v));
}

bool on_segment(Point p, Point a, Point b){ // 点是否在线段上
    return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <= 0;
}

bool segment_intersection(Point a1, Point a2, Point b1, Point b2){ // 判断两个线段是否相交
    T c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
    T c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
    return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
}
// 多边形
T polygon_area(Point p[], int n){ // 求多边形面积
    T s = 0;
    for (int i = 1; i + 1 < n; i++)
        s += cross(p[i] - p[0], p[i + 1] - p[i]);
    return s / 2;
}
```

### 点积

### 叉积

### 极角序

​	极角排序，就是平面上有若干点，选一点作为极点，那么每个点有极坐标 $(\rho,\theta)$，将它们关于极角 $\theta$ 排序。进行极角排序有两种方法。

​	第一种是**直接计算极角**，我们知道极坐标和直角坐标转换公式中有 $tan\theta = \frac{y}{x}$，所以可以用 $arctan\theta$ 来计算。然而， $arctan\theta$ 的值域只有 $(-\frac{\pi}{2},\frac{\pi}{2}]$，而且当 $x=0$  时无定义，所以需要复杂的分类讨论。所幸，`<cmath>`中有一个`atan2(y,x)`函数，可以直接计算`(x,y)`的极角，值域是 $(-\pi,\pi]$ ，所以可以直接用，只不过需要留心第四象限的极角会比第一象限小。在精度不够的时候尝试使用 $long\; double$

 	这是原点与极点重合的情况。对于选定的极点，对它到每个点的向量进行极角排序即可。

​	板子题：给定n个向量找到任意两个向量之间夹角的最小值并输出其下标。

```c++
const int N = 1e5+10;
const long double pi = acos(-1);

struct node{
	int x,y,id;
	long double ang;
	bool operator<(const node &t)const{
		return ang<t.ang;
	}
}p[N];

int main()
{
	IOS;
	int n;
	cin >> n;
	rep(i,1,n){
		int x,y;
		cin >> x >> y;
		p[i] = {x,y,i};
		p[i].ang = atan2((long double)y,(long double)x);
	}
	sort(p+1,p+n+1);
	long double ans = min(p[n].ang-p[1].ang,pi*2-p[n].ang+p[1].ang);
	int ans1 = p[n].id;
	int ans2 = p[1].id;
	
	for(int i=2;i<=n;i++){
		long double t = min(p[i].ang-p[i-1].ang,pi*2-p[i].ang+p[i-1].ang);
		if(t<ans){
			ans = t;
			ans1 = p[i-1].id;
			ans2 = p[i].id;
		}
	}
	cout << ans1 << " " << ans2 << endl;

	return 0;
}

```

## 线段相关

### 相交判定

### 交点

## 多边形相关

### 凸包

### 多边形包含

### 旋转卡壳

### 半平面交

## 圆相关

### 交点切线

### 面积交/并

简单版本：两个圆面积的交集

思路：先判断两个圆的位置关系然后进一步进行求解

```c++
ld pi = acos(-1);
ld xa,ya,ra,xb,yb,rb,ans;

ld sq(ld x)
{
	return x*x;
}

int main()
{
	cin >> xa >> ya >> ra >> xb >> yb >> rb;
	ld dis = sqrt(sq(xa-xb)+sq(ya-yb));
//	cout << dis << endl;
	if(dis>=ra+rb)
		ans = 0;
	else if(dis<=fabs(ra-rb))
		ans = sq(min(ra,rb))*pi;
	else{
		ld aa=acos((sq(ra)+sq(dis)-sq(rb))/2/ra/dis)*2;
		ld ab=acos((sq(rb)+sq(dis)-sq(ra))/2/rb/dis)*2;//计算出两个圆心角
		ans=aa/2*sq(ra)-sq(ra)/2*sin(aa)+ab/2*sq(rb)-sq(rb)/2*sin(ab);
//		cout << ans << endl;
	}
	printf("%.16Lf\n",ans);

	return 0;
}

```

## 凸包快速操作

## 三维计算几何

## 杂

### 数值积分

#### 辛普森积分

#### 自适应辛普森

### 点定位

### 最小圆覆盖

### Voronoi图

### 圆反演

### Picks定理