# 动态规划

## 背包问题

### 01背包

二维形式

拓展：背包问题不少于k这种情况的解法

解释：二维费用的背包问题，求的是不能超过体积$V$，重量$M$的情况下，能拿到价值的最大值。而本题是至少需要体积$V$，重量$M$的情况下，能拿到价值的最小值。就拿体积来说，至少需要多少体积，也就是说有体积比需要的体积大的物品还是能用得到，例如$f[3][5]$，至少需要3个体积，5个重量，求能拿到价值的最小值，现在只有一个物品，体积是4，重量是4，价值$w$，它说至少需要3个体积，那么体积是4还是可以用到，只是多了1个体积没用占着而已，不影响其价值。因此若用了这个物品，则变成了求$f[0][1] + w$，表示体积已经不再需求了，只需要0个体积即可

一维相关代码：

```c++
	memset(f,0x3f,sizeof f);
	
	f[0] = 0;
	for(int i=1;i<=n;i++){
		for(int j=m;j>=0;j--)
			f[j] = min(f[j],f[max(0,j-v[i])]+w[i]);
	}
```

二维相关代码：

```c++
	memset(f,0x3f,sizeof f);
    f[0][0] = 0;
    
    for(int i=1;i<=K;i++){
        for(int j=m;j>=0;j--){
            for(int k=n;k>=0;k--){
                f[j][k] = min(f[j][k],f[max(0,j-a[i])][max(0,k-b[i])]+c[i]);
            }
        }
    }
```

拓展：

求最大值最小值初始化总结
二维情况
1、体积至多$j$,$f[i,k] = 0$,$0 <= i <= n, 0 <= k <= m$（只会求价值的最大值）
2、体积恰好j
当求价值的最小值：$f[0][0] = 0$, 其余是$INF$
当求价值的最大值：$f[0][0] = 0$, 其余是$-INF$
3、体积至少$j$，$f[0][0] = 0$，其余是INF（只会求价值的最小值）

一维情况
1、体积至多$j$，$f[i] = 0, 0 <= i <= m$（只会求价值的最大值）
2、体积恰好$j$，
当求价值的最小值：$f[0] = 0$, 其余是$INF$
当求价值的最大值：$f[0] = 0$, 其余是$-INF$
3、体积至少$j$，$f[0] = 0$，其余是$INF$（只会求价值的最小值）

### 完全背包

二维形式

状态表示：$f[i][j]$ 表示从前i件物品里面选不超过容量j可以获得的最大价值

状态的划分：分为选多少个第$i$个物品

补充：$f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,...,f[i-1][j-sv]+sw)$

​		    $f[i][j-v] = max(    ,f[i-1][j-v],...,f[i-1][j-sv]+(s-1)w)$

对比得出状态转移方程：$f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i])$ 

可以分为一个都不选和至少选一个

```c++
for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j] = f[i-1][j];
            if(j>=v[i])
                f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);
        }
    }
```

一维形式

**优化为1维后只有完全背包是从小到大循环的**

```c++
for(int i=1;i<=n;i++){
        for(int j=v[i];j<=m;j++){
            f[j] = max(f[j],f[j-v[i]]+w[i]);
        }
    }
```

### 多重背包 

#### $O(nml)$ 暴力枚举

状态表示：$f[i][j]$ 表示从前i件物品里面选不超过容量j可以获得的最大价值

状态的划分：分为选多少个第$i$个物品

状态转移方程：$f[i][j] = max(f[i][j],f[i-1][j-k*v]+k*w)$

```c++
for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k <= s[i] && k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
```

#### $O(nmlog(l))$ 二进制优化

理解：用二进制的形式来拆分每个背包，对拆分后的背包进行01背包

代码：

```
const int N = 2e5+10; // 大小为原来物品的容量和体积求log

int v[N],w[N];
int dp[N];

int main()
{
	int n,m;
	cin >> n >> m;
	int cnt = 1;
	rep(i,1,n){
		int a,b,s;
		cin >> a >> b >> s;
		int x = 1;
		while(s>x){
			v[cnt] = a*x;
			w[cnt] = b*x;
			cnt++;
			s -= x;
			x *= 2;
		}
		if(s){
			v[cnt] = s*a;
			w[cnt] = s*b;
			cnt++;
		}
	}
	
	rep(i,1,cnt-1){
		per(j,m,v[i])
			dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
	}
	
	cout << dp[m] << endl;

 	return 0;
}

```

#### $O(nm)$ 单调队列优化

思路：

```c++
dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值
dp[i][j] = max(不放入物品 i，放入1个物品 i，放入2个物品 i, ... , 放入k个物品 i)
这里 k 要满足：k <= s, j - k*v >= 0

不放物品  i = dp[i-1][j]
放k个物品 i = dp[i-1][j - k*v] + k*w

dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2*v] + 2*w,..., dp[i-1][j-k*v] + k*w)
实际上我们并不需要二维的dp数组，适当的调整循环条件，我们可以重复利用dp数组来保存上一轮的信息

我们令 dp[j] 表示容量为j的情况下，获得的最大价值
那么，针对每一类物品 i ，我们都更新一下 dp[m] --> dp[0] 的值，最后 dp[m] 就是一个全局最优值

dp[m] = max(dp[m], dp[m-v] + w, dp[m-2*v] + 2*w, dp[m-3*v] + 3*w, ...)

接下来，我们把 dp[0] --> dp[m] 写成下面这种形式
dp[0], dp[v],   dp[2*v],   dp[3*v],   ... , dp[k*v]
dp[1], dp[v+1], dp[2*v+1], dp[3*v+1], ... , dp[k*v+1]
dp[2], dp[v+2], dp[2*v+2], dp[3*v+2], ... , dp[k*v+2]
...
dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j]
显而易见，m 一定等于 k*v + j，其中  0 <= j < v
所以，我们可以把 dp 数组分成 j 个类，每一类中的值，都是在同类之间转换得到的
也就是说，dp[k*v+j] 只依赖于 { dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j] }

因为我们需要的是{ dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j] } 中的最大值，
可以通过维护一个单调队列来得到结果。这样的话，问题就变成了 j 个单调队列的问题
所以，我们可以得到
dp[j]    =     dp[j]
dp[j+v]  = max(dp[j] +  w,  dp[j+v])
dp[j+2v] = max(dp[j] + 2w,  dp[j+v] +  w, dp[j+2v])
dp[j+3v] = max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])
...
但是，这个队列中前面的数，每次都会增加一个 w ，所以我们需要做一些转换
dp[j]    =     dp[j]
dp[j+v]  = max(dp[j], dp[j+v] - w) + w
dp[j+2v] = max(dp[j], dp[j+v] - w, dp[j+2v] - 2w) + 2w
dp[j+3v] = max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w
...
这样，每次入队的值是 dp[j+k*v] - k*w
单调队列问题，最重要的两点
1）维护队列元素的个数，如果不能继续入队，弹出队头元素
2）维护队列的单调性，即：尾值 >= dp[j + k*v] - k*w

本题中，队列中元素的个数应该为 s+1 个，即 0 -- s 个物品 i
```

代码：

```c++
const int N = 2e4+10;

int f[N],g[N],q[N]; // g是上一轮的值 

int main()
{
	int n,m;
	cin >> n >> m;
	rep(i,1,n){
		int v,w,s;
		cin >> v >> w >> s;
		memcpy(g,f,sizeof f);
		rep(j,0,v-1){ // 枚举余数
			int hh=0,tt=-1;
			for(int k=j;k<=m;k+=v){
				if(hh<=tt && q[hh]<k-s*v)
					hh++; // 如果队头滑出窗口了就谈出队头
				while(hh<=tt && g[q[tt]]-(q[tt]-j)/v*w <= g[k]-(k-j)/v*w)
					tt--; // 利用当前的值不断将比我小的值删除
				q[++tt] = k; // 插入当前值，注意插入的是体积也就是说每个单调队列里面维护的是体积
				f[k] = g[q[hh]]+(k-q[hh])/v*w; // 队头即为最大值。
			}
		}
	}
	cout << f[m] << endl;

 	return 0;
}

```

### 树形背包

#### $O(n^2)$

#### $O(n^3)$

思路：将每个子儿子看成一个物品组，那么在所有子儿子中选择就相当于分组背包（由于物品众多，因此采用将集合划分为在每个子儿子中选择的体积划分）。

代码：

```c++
const int N = 110;

int n,m; 
int v[N],w[N];
int h[N],e[N],ne[N],idx;
int f[N][N];

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx;
	idx++;
}

void dfs(int u)
{
	for(int i=h[u];i!=-1;i=ne[i]){ // 枚举物品组
		int son = e[i];
		dfs(e[i]);
		
		for(int j=m-v[u];j>=0;j--){ // 枚举体积 注意倒序枚举，因为优化了一维空间
			for(int k=0;k<=j;k++){ // 枚举决策
				f[u][j] = max(f[u][j],f[u][j-k]+f[son][k]);
			}
		}
	}
	
	per(i,m,v[u]) // 该物品是必须放的 因此在处理完子节点之后更新
		f[u][i] = f[u][i-v[u]]+w[u];
	rep(i,0,v[u]-1)
		f[u][i] = 0;
}

int main()
{
	cin >> n >> m;
	memset(h,-1,sizeof h);
	int root;
	rep(i,1,n){
		int p;
		cin >> v[i] >> w[i] >> p; 
		if(p == -1)
			root = i;
		else
			add(p,i);
	}
	
	dfs(root);
	cout << f[root][m] << endl;

 	return 0;
}

```

### 分组背包

思路：枚举每组物品中选择哪一个就行

模板：

```c++
const int N = 110;
int v[N][N],w[N][N],s[N];
int f[N];

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        cin >> s[i];
        for(int j=0;j<s[i];j++)
            cin >> v[i][j] >> w[i][j];
    }
    
    for(int i=1;i<=n;i++){
        for(int j = m;j>=0;j--){
            for(int k=0;k<s[i];k++){
                if(v[i][k]<=j)
                    f[j] = max(f[j],f[j-v[i][k]]+w[i][k]);
            }
        }
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```

### 混合背包

思路：每次读入一个物对物品分类进行操作即可。

模板：

```c++
#define rep(i,a,n) for(int i=a;i<=n;i++)

const int N = 1010;

int v[N],w[N],s[N];
int f[N];

/*
 0表示无限背包
 -1 表示是01背包
 其余表示是多重背包
*/

int main()
{
    int n,V;
    cin >> n >> V;
    
    rep(i,1,n)
        cin >> v[i] >> w[i] >> s[i];
    
    rep(i,1,n){
        if(s[i] == 0){
            rep(j,v[i],V){
                f[j] = max(f[j],f[j-v[i]]+w[i]);
            }
        }
        else{
            if(s[i]==-1)
                s[i] = 1;
            for(int k=1;k<=s[i];k<<=1){
                for(int j=V;j>=v[i]*k;j--){
                    f[j] = max(f[j],f[j-v[i]*k]+w[i]*k);
                }
                s[i]-=k;
            }
            
            if (s[i]) {
                for (int j = V;j >= v[i] * s[i];j--) 
                    f[j] = max (f[j],f[j - v[i] * s[i]] + w[i] * s[i]);
            }
        }
    }
    
    cout << f[V] << endl;
    
    return 0;
}
```

### 多维背包 

和一维背包类似，此处以二维的01背包为例

模板：

```c++
const int N = 110;

int dp[N][N];

int main()
{
	int n,V,M;
	cin >> n >> V >> M;
	rep(i,1,n){
		int v,m,w;
		cin >> v >> m >> w;
		for(int j=V;j>=v;j--){
			for(int k=M;k>=m;k--)
				dp[j][k] = max(dp[j][k],dp[j-v][k-m]+w);
		}
	}
	
	cout << dp[V][M] << endl;

 	return 0;
}
```

## 线性dp

### 数字三角形模型

例题：

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![2.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**分析：**

同时走：分别从$(1,1)(1,1)$出发走到终点$(n, n)(n, n)$
同时走两条路径，令$(i1,j1),(i2,j2)$分别表示两条路径所经过的点
$dp[i1][j1][i2][j2] $表示所有从$(1,1)(1,1)$走到$(i1,j1)(i2,j2)$路径的最大值
当$i1 == i2 $&&$ j1 == j2$时代表两条路径出现重复点，则只取一次$a[i1][j1]$的值

![321.png](https://cdn.acwing.com/media/article/image/2020/07/07/37963_efc94512c0-321.png)

观察可发现，当两条路径走的步长相同时，才有可能出现重复点
而我们所求中，对结果造成干扰的特殊情况正是‘出现重复点’，我们可以只考虑同时走（二者同时走一步）
优化一下可发现，因为每步同时走 $i1 + j1 == i2 + j2$ 必然成立
可令$k = i1 + j1$则$dp[i1][j1][i2][j2]$ 可转化为$ dp[k][i1][i2]$

```c++
const int N = 12;

int s[N][N];
int f[N*2][N][N];

int main()
{
    int n;
    cin >> n;
    int a,b,c;
    while(cin >> a >> b >> c && (a||b||c)){
        s[a][b] = c;
    }
    
    for(int k=2;k<=n*2;k++){
        for(int i1=1;i1<=n;i1++){
            for(int i2=1;i2<=n;i2++){
                int j1=k-i1,j2=k-i2;
                if(j1>=1 && j1<=n && j2>=1 && j2<=n){
                    int &x = f[k][i1][i2];
                    int t = s[i1][j1];
                    if(i1!=i2)
                        t += s[i2][j2];
                    x = max(x, f[k-1][i1-1][i2-1]+t);
                    x = max(x, f[k-1][i1-1][i2]+t);
                    x = max(x, f[k-1][i1][i2-1]+t);
                    x = max(x, f[k-1][i1][i2]+t);
                }
            }
        }
    }
    
    cout << f[n*2][n][n] << endl;
    
    return 0;
}
```

### 最长上升子序列模型

做法1：$O(n^2)$

思路：$f[i]$表示所有以$a[i]$结尾的上升子序列的长度的最大值

转移方程：枚举$1到i-1$ 如果$a[j]<a[i]$,则取最大值即可

```c++
const int N = 1010;

int n;
int a[N],f[N];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        cin >> a[i];
        
    for(int i=1;i<=n;i++){
        f[i] = 1;
        for(int j=1;j<i;j++){
            if(a[j]<a[i])
                f[i] = max(f[i],f[j]+1);
        }
    }
    
    int res = 0;
    for(int i=1;i<=n;i++)
        res = max(res,f[i]);
        
    cout << res << endl;
    
    return 0;
}
```

作法2：$O(nlog(n))$

思路：在暴力的基础上进行优化，$f[i]$转移的过程必然是寻找一个比$a[i]$小且长度最大的一个范围，因此我们可以开一个数组用来记录各个长度下所记录的最小值，也就是说对于每个长度为$len$的上升子序列，$q[len]$表示其最后一位的最小值，因为最小值最为适用，可以证得，该数组一定是上升的

证明：采用反证法，$q[len]$和$q[len+1]$ 如果$q[len]>=q[len+1]$，那就说明长度为$len+1$的序列倒数第二个数必然$<q[len+1]<=q[len]$,那么此时存在一个$len$的最优解比$q[len]$小，存在矛盾，说明$q[len]<q[len+1]$,具有二段性，因此可以二分。

代码：

```c++
int a[N];
int q[N];

int main()
{
    int n;
    scanf("%d",&n);
    
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
        
    int len = 0;
    for(int i=0;i<n;i++){
        int l = 0, r = len;
        while(l<r){
            int mid = l + r + 1>> 1;
            if(q[mid] < a[i])
                l = mid;
            else
                r = mid - 1;
        }
        len = max(len,r+1);
        q[r+1] = a[i];
    }
    
    cout << len << endl;
    
    return 0;
}
```

例题：

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

代码：

```c++
	int res = 0;
	int cnt = 0;
	for(int i=1;i<=n;i++){
		dp[i] = 1;
		for(int j=1;j<i;j++){
			if(a[j]>=a[i])
				dp[i]=(dp[i],dp[j]+1);
		}
		res = max(dp[i],res);
		int k=0;
		while(k<cnt && q[k]<a[i]) // 在序列里找到第一个比a[i]大的位置插进去 贪心
			k++;
		if(k==cnt)
			q[cnt++] = a[i];
		else
			q[k] = a[i];
	}
	cout << res << endl;
	cout << cnt << endl;
```

### 最长公共子序列

状态表示：

​	$dp[i][j]$表示所有在第一个序列的前$i$个字母中出现，且在第二个序列的前$j$个字母中出现的公共子序列的最大值。

状态转移：

​	$dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1](a[i]==b[j]))$

模板代码：

```c++
const int N = 1010;

char a[N],b[N];
int dp[N][N];

int main()
{
	int n,m; 
	cin >> n >> m;
	cin >> a+1 >> b+1;
	rep(i,1,n){
		rep(j,1,m){
			dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
			if(a[i] == b[j])
				dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);
		}
	}
	
	cout << dp[n][m] << endl;
 	return 0;
}
```

扩展：最长上升公共子序列

代码：

```c++
const int N = 3010;

int dp[N][N];
int a[N],b[N];

int main()
{
	int n;
	cin >> n;
	rep(i,1,n)
		cin >> a[i];
	rep(i,1,n)
		cin >> b[i];
	
	rep(i,1,n){
		int maxv = 1;
		rep(j,1,n){
			dp[i][j] = dp[i-1][j];
			if(a[i] == b[j])
				dp[i][j] = max(dp[i][j],maxv);
//				rep(k,1,j-1){
//					if(b[k]<b[j])
//						dp[i][j] = max(dp[i][j],dp[i-1][k]+1);
//				}
				// 在1到j-1内找一个最大的dp[i-1][k]+1 (并且小于a[i]) 
            	// 最后发现可以用一个变量来维护  maxv 表示的就是第二个循环内所找的内容
				/*
					if(b[k]<a[i])
				*/
			if(b[j]<a[i])
				maxv = max(maxv,dp[i][j]+1);
		}
	}
	
	int res = 0;
	rep(i,1,n)
		res = max(res,dp[n][i]);
	cout << res << endl;
	
 	return 0;
}

```

## 区间dp

迭代式写法：

模板题：石子合并

```
const int N = 310;
int w[N];
int dp[N][N];
int n;

int main()
{
	cin >> n;
	rep(i,1,n){
		cin >> w[i];
		w[i] += w[i-1]; 
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			dp[l][r] = inf;
			for(int k=l;k<r;k++)
				dp[l][r] = min(dp[l][r],dp[l][k]+dp[k+1][r]+w[r]-w[l-1]);
		}
	}
	
	cout << dp[1][n] << endl;

 	return 0;
}

```

记忆化搜索写法:

```c++
const int N = 20;

int n,m=8;
int s[N][N];
double f[9][9][9][9][N];
double X;

double get_sum(int x1,int y1,int x2,int y2)
{
	return s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
}

double get(int x1,int y1,int x2,int y2)
{
	double sum = get_sum(x1,y1,x2,y2)-X;
	return (double)sum*sum/n;
}

double dp(int x1,int y1,int x2,int y2,int k)
{
	double &v=f[x1][y1][x2][y2][k];
	if(v>=0)
		return v;
	if(k==1)
		return v=get(x1,y1,x2,y2);
	
	v = inf;
	for(int i=x1;i<x2;i++){
		v = min(v,get(x1,y1,i,y2)+dp(i+1,y1,x2,y2,k-1));
		v = min(v,get(i+1,y1,x2,y2)+dp(x1,y1,i,y2,k-1));	
	}
	
	for(int i=y1;i<y2;i++){
		v = min(v,get(x1,y1,x2,i)+dp(x1,i+1,x2,y2,k-1));
		v = min(v,get(x1,i+1,x2,y2)+dp(x1,y1,x2,i,k-1));	
	}
	
	return v;
}

int main()
{
	cin >> n;
	rep(i,1,m){
		rep(j,1,m){
			cin >> s[i][j];
			s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];
		}
	}
	
	X = (double)s[m][m]/n;
	memset(f,-1,sizeof f);
	
	printf("%.3lf\n",sqrt(dp(1,1,8,8,n)));

 	return 0;
}

```

## 计数dp

## 数位dp

尤其强调分类讨论：

模板是找出每个位置上数字出现的次数。
比如说我要找 $[1,abcdefg]$ 中的数中1出现的个数
就得先求1在每一个位置上出现的次数，总和就是总共出现的次数。

假设原始数字是 $abcdefg$ , 现在要找第四位上出现1的个数有几个。

就是要找满足 $1<=xxx1yyy<=abcdefg$  

1. xxx∈[000,abc-1] , yyy∈[000,999] , ans += abc*1000
   //如果前三位没填满，则后三位就可以随便填

2. xxx==abc , yyy∈?
   if(d<1) yyy不存在 , ans += 0
   if(d==1) yyy∈[000,efg] , ans += efg+1
   if(d>1) yyy∈[000,999] , ans += 1000
   //如果前三位填满了，后三位怎么填取决于当前这一位

   

   但是有一些特殊情况

   1. x在第一位上出现的次数

      ```c++
      bcdefg∈[00000,bcdefg] , ans += bcdefg+1
      ```

   2. 如果我们枚举的数是0的话 ：

      ```c++
      //恶魔讨论
      0不能在第一位 
      而且枚举到的这一位前面不能全是0，即
      xxx∈[001,abc-1]
      ```

代码：

```c++
int get(vector<int> num, int l, int r)
{
    int res = 0;
    for (int i = l; i >= r; i -- ) res = res * 10 + num[i];
    return res;
}

int power10(int x)
{
    int res = 1;
    while (x -- ) res *= 10;
    return res;
}

int count(int n,int x)
{
	if(!n)
		return 0;
	
	vector<int> num;
	while(n){
		num.pb(n%10);
		n /= 10;
	}
	n = num.size();
	int res = 0;
	//
	for(int i=n-1-!x;i>=0;i--){
		if(i<n-1){
			res += get(num,n-1,i+1)*power10(i);
			if(!x)
				res -= power10(i);
		}
		
		if(num[i] == x)
			res += get(num,i-1,0)+1;
		else if(num[i] > x)
			res += power10(i);
	}
	return res;
}

int main()
{
	IOS;
	int a,b;
	while(cin >> a >> b,a || b){
		if(a>b)
			swap(a,b);
		for(int i=0;i<10;i++){
			cout << count(b,i) - count(a-1,i) << " ";
		}
		cout << endl;
	}

	return 0;
}
```

代码：

用来统计 不超过3个非零数的所有方案。

```c++
int a[20];
ll dp[20][5]; // 表示前i个数字中 j个位置是非零的所有方案 （没有限制的话）
// 没有限制意味着 后面 几个数可以从 0000~9999 这种方案我们可以记忆化记录一下。 

ll dfs(int pos,int cnt,bool limit)
{
	if(pos == -1)
		return 1;
	int up = limit?a[pos]:9;
	if(!limit && dp[pos][cnt] != -1)
		return dp[pos][cnt];
	ll ans = 0;
	for(int i=0;i<=up;i++){
		if(i == 0)
			ans += dfs(pos-1,cnt,limit && a[pos]==i);
		else{
			if(cnt<3)
				ans += dfs(pos-1,cnt+1,limit && a[pos]==i);
		}
	}
	if(!limit)
		dp[pos][cnt] = ans;
	return ans;
}

ll calc(ll x)
{
	int tot=0;
	while(x){
		a[tot++] = x%10;
		x /= 10;
	}
	ll ans = dfs(tot-1,0,true);
	return ans;
}

int main()
{
	IOS;
	int t;
	cin >> t;
	memset(dp,-1,sizeof dp);
	while(t--){
		ll a,b;
		cin >> a >> b;
		cout << calc(b)-calc(a-1) << endl;
	}

	return 0;
}

```

## 树形dp

模板题：没有上司的舞会

树形dp一般思路：

​	设$dp[u][0]$表示在以u为根的子树中不选择根的所有情况下的最优解，$dp[u][1]$表示在以u为根的子树中选择根的所有情况下的最优解，通常通过搜索的方式获得子节点的两个值，再根据集合的划分来求解当前节点下的值。

扩展：特殊情况下导致两个状态可能不太够表达出所有的状态，因此采用状态机模型里面的理论，扩展状态进行计算。

```c++
const int N = 6010;
int happy[N];
int h[N],e[N],ne[N],idx;
int f[N][2];
bool has_father[N];

void add(int a,int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx;
    idx++;
}

void dfs(int u)
{
    f[u][1] = happy[u];
    
    for(int i=h[u];i!=-1;i=ne[i]){
        int j = e[i];
        dfs(j);
        
        f[u][0] += max(f[j][0],f[j][1]);
        f[u][1] += f[j][0];
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&happy[i]);
        
    memset(h,-1,sizeof h);
    
    for(int i=0;i<n-1;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        has_father[a] = true;
        add(b,a);
    }
    
    int root = 1;
    while(has_father[root])
        root++;
    
    dfs(root);
    
    printf("%d\n",max(f[root][1],f[root][0]));
    
    return 0;
}
```

## 状压dp

### 普通型

### 轮廓线型

### 高维前缀和

### 动态高维前缀和

## 插头dp

## 概率dp

## 其他类型

### 图上dp

### 基环树上dp

### 自动机上dp

### 分治dp

### 填坑dp

### 动态dp

### dp套dp

## dp优化

### 单调栈优化

### 单调队列优化

### 四边型不等式优化

### 斜率优化

```c++
const int N = 5e5+10;

ll a[N],s[N],dp[N];
int q[N];

ll dy(int i,int j)
{
	return dp[i]+s[i]*s[i]-dp[j]-s[j]*s[j];
}

ll dx(int i,int j)
{
	return s[i]-s[j];
}

int main()
{
	IOS;
	int n,m;
	while(cin >> n >> m){
		rep(i,1,n){
			cin >> a[i];
			s[i] = s[i-1]+a[i];
		}
		int hh=1,tt=0;
		rep(i,1,n){
			while(hh<tt && dy(i-1,q[tt])*dx(q[tt],q[tt-1])<=dy(q[tt],q[tt-1])*dx(i-1,q[tt])) tt--;
			q[++tt] = i-1;
			while(hh<tt && dy(q[hh+1],q[hh])<=dx(q[hh+1],q[hh])*2*s[i]) hh++;
			int j=q[hh];
			dp[i] = dp[j]+(s[i]-s[j])*(s[i]-s[j])+m;
		}
		cout << dp[n] << endl;
	}

	return 0;
}
```

### 数据结构优化

### 决策单调性