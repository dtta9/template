# **数据结构**

## 队列

### 单调队列

二维滑动窗口的最值

题目描述：有一个$n×m$的整数组成的矩阵，现请你从中找出一个$k$的正方形区域，使得该区域所有数中的最大值和最小值的差最小。

思路：先对行进行单调队列求最值，求出以该点为右端点的长度为k的区间内的一个最值，接着我们对操作得到的数组在列方向上利用单调队列求最值，这样就可得到长度为k的一个正方形的区域的最值。

```c++
const int N = 1010;

int n,m,k;
int w[N][N],q[N];
int row_max[N][N];
int row_min[N][N];

void get_min(int a[],int b[],int tot)
{
	int hh=0,tt=-1;
	rep(i,1,tot){
		if(hh<=tt && q[hh]<=i-k)
			hh++;
		while(hh<=tt && a[q[tt]] >= a[i])
			tt--;
		q[++tt] = i;
		b[i] = a[q[hh]];
	}
}

void get_max(int a[], int b[], int tot)
{
    int hh=0,tt=-1;
   	rep(i,1,tot){
        if(hh<=tt && q[hh]<=i-k) 
        	hh++;
        while(hh<=tt && a[q[tt]]<=a[i]) 
        	tt--;
        q[++tt] = i;
        b[i] = a[q[hh]];
    }
}

int main()
{
	cin >> n >> m >> k;
	rep(i,1,n){
		rep(j,1,m)
			cin >> w[i][j];
	}
	
	rep(i,1,n){
		get_min(w[i],row_min[i],m); // 处理每一行的最小值
		get_max(w[i],row_max[i],m); // 处理每一行的最大值
	}
	
	int res = inf;
	int a[N],b[N],c[N];
	rep(i,k,m){
		rep(j,1,n)
			a[j] = row_min[j][i]; // 取出每一列
		get_min(a,b,n);           // 以该列为元素取最小
		rep(j,1,n)
			a[j] = row_max[j][i];
		get_max(a,c,n);
		rep(j,k,n)
			res = min(res,c[j]-b[j]); // 依次枚举
	}
	
	cout << res << endl;
	
 	return 0;
}

```

## 栈

**应用：中缀表达式求值**

```c++
stack<int> num;
stack<char> op;

unordered_map<char, int> h{ {'+', 1}, {'-', 1}, {'*',2}, {'/', 2} };

void eval()
{
	int a = num.top();//第二个操作数
    num.pop();
    int b = num.top();//第一个操作数
    num.pop();
    char p = op.top();//运算符
    op.pop();
    int r = 0;//结果 
    //计算结果
    if (p == '+') r = b + a;
    if (p == '-') r = b - a;
    if (p == '*') r = b * a;
    if (p == '/') r = b / a;
    num.push(r);//结果入栈
}

int main()
{
	string s;
	cin >> s;
	for(int i=0;s[i];i++){
		if(isdigit(s[i])){
			int x=0,j=i;
			while(j<s.size() && isdigit(s[j])){
				x = x*10+s[j]-'0';
				j++;
			}
			num.push(x);
			i = j-1;
		}
		else if(s[i] == '('){
			op.push(s[i]);
		}
		else if(s[i] == ')'){
			// 如果出现右括号 就将左右括号内的数从右到左进行一遍运算
			// 之所以从右到左是因为下面的操作已经将括号内的优先级顺序弄成了非递减的序列
			while(op.top() != '(')
				eval();
			op.pop();
		}
		else{
            // 处理左边优先级大于等于我的
			while(op.size() && h[op.top()] >= h[s[i]])
				eval();
			op.push(s[i]);
		}
	}
	
	while(op.size())
		eval();
	cout << num.top() << endl;

 	return 0;
}
```

## 链表

### 普通链表

### 双向链表

简单题意：给定一个数组，每个数都会被左边比它大的数吃掉，问总共能吃几轮

考虑链表优化删除的复杂度，考虑到总共的删除次数是不超过 n 次的，因此考虑模拟链表的话复杂度近似 O(n)

思想：f 数组表示一个数是否被删除，x 集合里存的是上一轮存活下来的数，y 是存的当前轮被删除的数

```c++
const int N = 1e5+10;

int a[N],l[N],r[N];
bool f[N];

int main()
{
	IOS;
	int n;
	cin >> n;
	set<ll> x,y;
	rep(i,1,n){
		cin >> a[i];
		l[i] = i-1;
		r[i] = i+1;
		f[i] = 1;
		x.insert(i);
	}
	l[1] = r[n] = 0;
	int ans = n;
	rep(cnt,1,n){
		for(auto u:x){
			if(a[l[u]]>a[u]){
				y.insert(u);
				f[u] = 0;
			}
		}
		x.clear();
		if(y.size() == 0){
			ans = cnt-1;
			break;
		}
		else{
			for(auto u:y){
				l[r[u]] = l[u];
				r[l[u]] = r[u];
				if(f[l[u]]) x.insert(l[u]);
				if(f[r[u]]) x.insert(r[u]);
			}
			y.clear();
		}
	}

	cout << ans << endl;

	return 0;
}
```

### 循环链表

## 堆

### 对顶堆

动态维护中位数

```c++
int main()
{
	IOS;
	int n;
	cin >> n;
	priority_queue<int> q1;
	priority_queue<int,vector<int>,greater<int>> q2;
	rep(i,1,n){
		int x;
		cin >> x;
		if(i == 1){
			q1.push(x);
			cout << x << endl;
		}
		else{
			if(x>q1.top()) q2.push(x);
			else q1.push(x);
			while(abs(q1.size()-q2.size()>1)){
				if(q1.size()>q2.size()){
					q2.push(q1.top());
					q1.pop();
				}
				else{
					q1.push(q2.top());
					q2.pop();
				}
			}
			if(i&1) cout << (q1.size()>q2.size()?q1.top():q2.top()) << endl;
		}
	}
	return 0;
}
```

### 可删除堆

```c++
template <class T> struct heap {
    priority_queue<T> A,B;
    void push(T x){
        A.push(x);
    }
    void erase(T x){
        B.push(x);
    }
    void pop(){
        while(B.size() && A.top()==B.top()) A.pop(),B.pop();
        A.pop();
    }
    T top(){
        while(B.size() && A.top()==B.top()) A.pop(),B.pop();
        if(!A.size()) return 0;
        return A.top();
    }
    int size(){
        return A.size()-B.size();
    }
};
```

### 斐波那契堆

### 左偏堆

## 树

### 树的基础

#### 树的基本概念

#### 树的遍历

#### 树的重心

#### 树的直径

搜索的方法：

​	随意从一个点开始搜索，找到离它最远的点，再从这个点开始搜索，找到离这个点最远的点，则该两点之间的距离就是树的直径。(证明略)。

```c++
const int N = 1e4+10, M=N*2;

int h[N],e[M],ne[M],w[M],idx;
int d[N];

void add(int a,int b,int c)
{
	e[idx] = b;
	w[idx] = c;
	ne[idx] = h[a];
	h[a] = idx;
	idx++;
}

void dfs(int u,int fa,int &r)
{
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j==fa)
			continue;
		if(d[j] < d[u]+w[i])
			d[j] = d[u]+w[i];
		dfs(j,u,r); 
	}
	
	if(d[u]>d[r])
		r = u;
}

int main()
{
	int n;
	cin >> n;
	memset(h,-1,sizeof h);
	rep(i,1,n-1){
		int a,b,c;
		cin >> a >> b >> c;
		add(a,b,c);
		add(b,a,c);
	}
	
	int r1 = 0;
	d[r1] = -1e9;
	dfs(1,-1,r1);
    
	int r2 = 0;
	memset(d,0,sizeof d);
	dfs(r1,-1,r2);
	cout << d[r2] << endl;

 	return 0;
}

```

动态规划法：

​	在一个树中，树中任意两点之间的路径可以根据其路径中最高点来进行划分，那么根据这样的划分直径其实就是一个节点向下走的最大距离和次大距离之和，因此在搜索中记录两个值即可。

```c++
const int N = 1e4+10,M = N*2;

int ans;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx] = b;
	w[idx] = c;
	ne[idx] = h[a];
	h[a] = idx;
	idx++;
}
 
int dfs(int u,int fa)  // 返回的是向下走的最大值
{
	int dist = 0;
	int d1 = 0;
	int d2 = 0;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j = e[i];
		if(j == fa)
			continue;
		int d = dfs(j,u)+w[i];
		dist = max(d,dist);
		
		if(d>d1){
			d2 = d1;
			d1 = d;
		}
		else if(d>d2)
			d2 = d;
	}
	
	ans = max(ans,d1+d2);
	return dist;
}

int main()
{
	int n;
	cin >> n;
	memset(h,-1,sizeof h);
	rep(i,1,n-1){
		int a,b,c;
		cin >> a >> b >> c;
		add(a,b,c);
		add(b,a,c);
	}
	
	dfs(1,-1);
	
	cout << ans << endl;

 	return 0;
}

```

#### $LCA$(最近公共祖先)

##### 倍增法

思路：

利用$2$进制优化的思想，设从该节点到最近公共祖先需要$k$步，则这$k$步一定可以用二进制所拼凑出来，同时也利用动态规划的思想，$2^j$ 步等于先跳$2^{j-1}$ 步跳到其祖先位置，再跳$2^{j-1}$步,而其祖先的$fa$数组在$bfs$的时候已经处理过了，大大优化时间

$fa[i][j]$表示从$i$开始，向上走$2^j$ 步所能走到的节点。$0<=j<=log(n)$

$depth[i]$表示深度，根节点深度为$1$

哨兵：如果从$i$开始跳$2^j$步会跳过根节点，那么$fa[i,j] = 0,dpeth[0] = 0$,设置哨兵的好处会在代码里面显示

步骤：(1)先让两个点跳到同一层

​			(2)让两个点同时往上跳，一直跳到他们的最近公共祖先的下一层,之所以跳到下一层是为了方便判断，如果跳到更高层可能会跳到最近公共祖先的父节点，也满足等于的条件，不符合题意

时间复杂度：预处理$nlog(n)$

​						查询$log(n)$

代码：

```c++
const int N = 3e5+10,M = N*2;
const int bit = 20;

int depth[N],num[N];
int n,m,a[N],fa[N][bit];
int h[N],e[M],ne[M],idx;

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void bfs(int root)
{
	memset(depth,0x3f,sizeof depth);
	depth[0] = 0;
	depth[root] = 1;
	
	queue<int> q;
	q.push(root);
	while(q.size()){
		int t=q.front();
		q.pop();
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];
			if(depth[j]>depth[t]+1){
				depth[j] = depth[t]+1;
				q.push(j);
				fa[j][0] = t;
				for(int k=1;k<bit;k++)
					fa[j][k] = fa[fa[j][k-1]][k-1];
			}
		}
	}
}

int lca(int a,int b)
{
	if(depth[a]<depth[b]) 
		swap(a,b);
	for(int k=bit-1;k>=0;k--){
		if(depth[fa[a][k]] >= depth[b])
			a = fa[a][k];
	}
	if(a == b) 
		return a;
	for(int k=bit-1;k>=0;k--){
		if(fa[a][k] != fa[b][k]){
			a = fa[a][k];
			b = fa[b][k];
		}
	}
	return fa[a][0];
}
```

树上差分：

考虑把每个边的权值算入到深度较深的子节点中

```c++
const int N = 1e5+10,M=N*2;

int n,k;
int depth[N],d[N];
int fa[N][20];
int h[N],e[M],ne[M],idx;
PII edge[N];

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void bfs(int root)
{
	memset(depth,0x3f,sizeof depth);
	depth[0] = 0;
	depth[root] = 1;
	
	queue<int> q;
	q.push(root);
	while(q.size()){
		int t=q.front();
		q.pop();
		
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];
			if(depth[j]>depth[t]+1){
				depth[j] = depth[t]+1;
				q.push(j);
				fa[j][0] = t;
				for(int k=1;k<=18;k++){
					fa[j][k] = fa[fa[j][k-1]][k-1];
				}
			}
		}
	}
}

int lca(int a,int b)
{
	if(depth[a]<depth[b])
		swap(a,b);
	for(int k=18;k>=0;k--){
		if(depth[fa[a][k]] >= depth[b]) //如果2^k步跳出树了，depth[0] = 0,此时if条件绝对不成立
			a = fa[a][k];
	}
	
	if(a == b)
		return a;
	
	for(int k=18;k>=0;k--){
		if(fa[a][k] != fa[b][k]){
			a = fa[a][k];
			b = fa[b][k];
		}
	}
	
	return fa[a][0];
}

void dfs(int u,int fa)
{
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == fa)
			continue;
		dfs(j,u);
		d[u] += d[j];
	}
}


int main()
{
	IOS;
	cin >> n;
	memset(h,-1,sizeof h);
	rep(i,1,n-1){
		int a,b;
		cin >> a >> b;
		edge[i] = {a,b};
		add(a,b);
		add(b,a);
	}
	
	bfs(1);
	
	int k;
	cin >> k;
	rep(i,1,k){
		int a,b;
		cin >> a >> b;
		int p = lca(a,b);
		d[a]++;
		d[b]++;
		d[p]-=2;
//		cout << a << " " << b << " " << p << endl;
	}
	
//	rep(i,1,n)
//		cout << d[i] << " ";
//	
	dfs(1,-1);
	
	for(int i=1;i<=n-1;i++){
		auto [a,b] = edge[i];
		if(fa[a][0] != b)
			swap(a,b);
//		cout << a << endl;
		cout << d[a] << " ";
	}
	cout << endl;
	
	return 0;
}

```

##### $Tanjan$（离线求$lca$）

思路：

代码：

```c++
const int N = 10010,M = N*2;

int n,m;
int h[N],e[M],w[M],ne[M],idx;
int dist[N],p[N],res[M];
int st[N];
vector<PII> query[N];

void add(int a,int b,int c)
{
	e[idx] = b;
	w[idx] = c;
	ne[idx] = h[a];
	h[a] = idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == fa)
			continue;
		dist[j] = dist[u]+w[i];
		dfs(j,u);
	}
}

int find(int x)
{
	if(p[x] != x)
		p[x] = find(p[x]);
	return p[x];
}

void tarjan(int u)
{
	st[u] = 1;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(!st[j]){
			tarjan(j);
			p[j] = u;
		}
	}
	
	for(auto item:query[u]){
		int y=item.fi,id=item.se;
		if(st[y] == 2){
			int anc = find(y);
			res[id] = dist[u]+dist[y]-dist[anc]*2;
		}
	}
	
	st[u] = 2;
}

signed main()
{
	IOS;
	cin >> n >> m;
	memset(h,-1,sizeof h);
	for(int i=1;i<=n-1;i++){
		int a,b,c;
		cin >> a >> b >> c;
		add(a,b,c);
		add(b,a,c);
	}
	
	rep(i,0,m-1){
		int a,b;
		cin >> a >> b;
		if(a != b){
			query[a].pb({b,i});
			query[b].pb({a,i});
		} 
	}
	
	for(int i=1;i<=n;i++)
		p[i] = i;
	
	dfs(1,-1);
	tarjan(1);

	rep(i,0,m-1)
		cout << res[i] << endl;

 	return 0;
}
```

#### $dfn$

#### 括号序

### 线段树

**动态开点**

​	有时题目值域过大但是用到的点却很少 在不支持离线化的操作上要进行动态开点 每次插入最多创建$log(n)$个点，注意空间

相关代码：

```c++
const int N = 1e5+10;

int cnt = 1,tree[N*50],ch[N*50][2];//记录左儿子和右儿子的下表
ll a[N];

void insert(int p,ll l,ll r,ll x,int z) // 在x上加上z
{
	tree[p] += z;
	if(l==r)
		return ;
	ll mid = l+r>>1;
	if(x<=mid){
		if(!ch[p][0]) // 如果左儿子没有被开辟就开
			ch[p][0] = ++cnt;
		insert(ch[p][0],l,mid,x,z);
	}
	else{
		if(!ch[p][1])
			ch[p][1] = ++cnt;
		insert(ch[p][1],mid+1,r,x,z);
	}
}

ll query(int p,ll l,ll r,ll x,ll y) // 查询x到y区间上的和
{
	if(!p)
		return 0;
	if(x>y)
		return 0;
	if(l>=x && r<=y) // 如果已经被包含了直接返回
		return tree[p];
	ll mid = l+r>>1;
	ll res = 0;
	if(x<=mid)
		res += query(ch[p][0],l,mid,x,y);
	if(y>mid)
		res += query(ch[p][1],mid+1,r,x,y);
	return res;	
}
```

#### 带标记的线段树

**区间修改与区间查询**

**pushup与pushdown的时机：**

pushup发生在修改之后更新父节点信息之后

pushdown发生在查询时更新子节点和更改时传递父节点的信息给子节点

```c++
const int N = 2e5+10;

struct node{
	int l,r;
	ll sum,add;
}tr[N<<2];
int a[N];

void pushup(int u)
{
	tr[u].sum = tr[u<<1].sum+tr[u<<1|1].sum;
}

void pushdown(int u)
{
	auto &a=tr[u],&b=tr[u<<1],&c=tr[u<<1|1];
	if(a.add){
		b.sum += a.add*(b.r-b.l+1);
		c.sum += a.add*(c.r-c.l+1);
		b.add += a.add;
		c.add += a.add;
		a.add = 0;
	}
}

void build(int u,int l,int r)
{
	tr[u] = {l,r,0,0};
	if(l == r){
		tr[u].sum = a[l];
		return ;
	}
	int mid = tr[u].l+tr[u].r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	pushup(u);
}

void modify(int u,int l,int r,int d)
{
	if(tr[u].l>=l && tr[u].r <= r){
		tr[u].sum += 1ll*(tr[u].r-tr[u].l+1)*d;
		tr[u].add += d;
		return ;
	}
	else{
		pushdown(u);
		int mid = tr[u].l+tr[u].r>>1;
        if (l <= mid) modify(u<<1,l,r,d);
        if (r > mid) modify(u<<1|1,l,r,d);
        pushup(u);
	}
}

ll query(int u,int l,int r)
{
	if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
	pushdown(u);
	int mid = tr[u].l+tr[u].r>>1;
	ll sum = 0;
	if(l<=mid) sum += query(u<<1,l,r);
	if(r>mid) sum += query(u<<1|1,l,r);
	return sum; 
}
```

#### 区间最值线段树

简单介绍：区间最值就是给一个区间里面取min或者max,普通的标记时间复杂度难以保证，这里加入次大值的tag用来剪枝，可以保证复杂度在log级别内。

例题：这里取的是min操作。

```c++
const int N = 1e6+10;
int a[N];
ll mx[N<<2],se[N<<2],sum[N<<2],num[N<<2];

void pushup(int u)
{
	sum[u] = sum[lc(u)]+sum[rc(u)];
	mx[u] = max(mx[lc(u)],mx[rc(u)]);
	if(mx[lc(u)] == mx[rc(u)]){
		se[u] = max(se[lc(u)],se[rc(u)]);
		num[u] = num[lc(u)]+num[rc(u)];
	}
	else{
		se[u] = max(se[lc(u)],se[rc(u)]);
		se[u] = max(se[u],min(mx[lc(u)],mx[rc(u)]));
		num[u] = mx[lc(u)]>mx[rc(u)]?num[lc(u)]:num[rc(u)];
	}
}

void build(int u,int l,int r)
{
	if(l == r){
		sum[u] = mx[u] = a[l];
		se[u] = -1;
		num[u] = 1;
		return ;
	}	
	int mid = l+r>>1;
	build(lc(u),l,mid);
	build(rc(u),mid+1,r);
	pushup(u);
} 

inline void addtag(int u,int x)
{
	if(x >= mx[u])
		return ;
	sum[u] -= num[u]*(mx[u]-x);
	mx[u] = x;
}

inline void pushdown(int u)
{
	addtag(lc(u),mx[u]);
	addtag(rc(u),mx[u]);
}

void modify(int u,int pl,int pr,int l,int r,int x)
{
	if(mx[u] <= x)
		return ;
	if(pl >= l && pr <= r && se[u] < x){
		addtag(u,x);
		return ;
	}
	pushdown(u);
	int mid = pl+pr>>1;
	if(l<=mid)
		modify(lc(u),pl,mid,l,r,x);
	if(r>mid)
		modify(rc(u),mid+1,pr,l,r,x);
	pushup(u);
}

ll queryMax(int u,int pl,int pr,int l,int r)
{
	if(pl >= l && pr <= r)
		return mx[u];
	pushdown(u);
	int mid = pl+pr>>1;
	ll ans = 0;
	if(l<=mid)
		ans = max(ans,queryMax(lc(u),pl,mid,l,r));
	if(r>mid)
		ans = max(ans,queryMax(rc(u),mid+1,pr,l,r));
	return ans;
}

ll querySum(int u,int pl,int pr,int l,int r)
{
	if(pl >= l && pr <= r)
		return sum[u];
	pushdown(u);
	int mid = pl+pr>>1;
	ll ans = 0;
	if(l<=mid)
		ans += querySum(lc(u),pl,mid,l,r);
	if(r>mid)
		ans += querySum(rc(u),mid+1,pr,l,r);
	return ans;
}

void solve()
{
	int n,m;
	scanf("%d%d",&n,&m);
	rep(i,1,n)
		scanf("%d",&a[i]);
	build(1,1,n);
	while(m--){
		int op,l,r,x;
		scanf("%d%d%d",&op,&l,&r);
		if(op == 0){
			scanf("%d",&x);
			modify(1,1,n,l,r,x);
		}
		else if(op == 1){
			ll ans = queryMax(1,1,n,l,r);
			printf("%lld\n",ans);
		}
		else{
			ll ans = querySum(1,1,n,l,r);
			printf("%lld\n",ans);
		}
	}
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		solve();

	return 0;
}

```

#### 可持久化线段树

板子题 求静态区间 $[l,r]$ 的第 $k$ 小。

```c++
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
const int N = 2e5+10;

struct node{
	int ch[2];
	int s;
}tr[N*22];
int root[N],idx;
vector<int> v;
int a[N];

void build(int &x,int l,int r)
{
	x = ++idx;
	if(l == r) return;
	int mid = l+r>>1;
	build(lc(x),l,mid);
	build(rc(x),mid+1,r);
}

void insert(int x,int &y,int l,int r,int v)
{
	y = ++idx;
	tr[y] = tr[x];
	tr[y].s++;
	if(l == r) 	return ;
	int mid = l+r>>1;
	if(v <= mid) insert(lc(x),lc(y),l,mid,v);
	else insert(rc(x),rc(y),mid+1,r,v);
}

int query(int x,int y,int l,int r,int k)
{
	if(l == r) return l;
	int mid = l+r>>1;
	int s = tr[lc(y)].s-tr[lc(x)].s;
	if(k <= s) return query(lc(x),lc(y),l,mid,k);
	else return query(rc(x),rc(y),mid+1,r,k-s);
}

int get(int x)
{
	return lower_bound(v.begin(),v.end(),x)-v.begin()+1;
}

int main()
{
	IOS;
	
	int n,q;
	cin >> n >> q;
	rep(i,1,n){
		cin >> a[i];
		v.pb(a[i]);
	}
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());
	
	int len = v.size();
	build(root[0],1,len);
	rep(i,1,n)
		insert(root[i-1],root[i],1,len,get(a[i]));
		
	rep(i,1,q){
		int l,r,k;
		cin >> l >> r >> k;
		int ans = query(root[l-1],root[r],1,len,k);
		cout << v[ans-1] << endl;
	}
	return 0;
}
```

#### 李超线段树

#### 线段树合并

#### ZKW线段树

### 树状数组

```c++
template <class T> struct Fenwick {
    int n;
    vector<T> tr;
    Fenwick(const int &n = 0) : n(n), tr(n+10, T()){}
    inline int lowbit(int x)
    {
        return x&(-x);
    }
    void add(int x, T c) {
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i] += c;
    }
    T get(int x) {
        T res = 0;
        for(int i=x;i>0;i-=lowbit(i))
            res += tr[i];
        return res;
    }
    T sum(int l, int r){ //[l,r]
        return get(r)-get(l-1);
    }
    int kth(int k){ // 如果返回n+1 表示没有第k小的 
        int ans=0,cnt=0;
        int len = (floor)(log2(n));
        for(int i=len;i>=0;i--){
            ans += (1<<i);
            if(ans>n || cnt+tr[ans]>=k)
                ans -= (1<<i);
            else 
                cnt += tr[ans];
        }
        return ++ans;
    }
};
```

#### 树状数组求区间里面不同数的个数

思路：先考虑离线查询，然后将查询的区间排序，维护一个数最后出现的位置，每次将前一个数的贡献减去即可。

代码：

```c++
const int N = 1e6+10;

int a[N],p[N],ans[N];

struct node{
	int l,r;
	int id;
	bool operator<(const node &t)const{
		return r<t.r;
	}
}s[N];

template <class T> struct Fenwick {
    int n;
    vector<T> tr;
    Fenwick(const int &n = 0) : n(n), tr(n+10, T()){}
    inline int lowbit(int x)
    {
        return x&(-x);
    }
    void add(int x, T c) {
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i] += c;
    }
    T get(int x) {
        T res = 0;
        for(int i=x;i>0;i-=lowbit(i))
            res += tr[i];
        return res;
    }
    T sum(int l, int r){ //[l,r]
        return get(r)-get(l-1);
    }
    int kth(int k){ // 如果返回n+1 表示没有第k大的 
        int ans=0,cnt=0;
        int len = (floor)(log2(n));
        for(int i=len;i>=0;i--){
            ans += (1<<i);
            if(ans>n || cnt+tr[ans]>=k)
                ans -= (1<<i);
            else 
                cnt += tr[ans];
        }
        return ++ans;
    }
};

int main()
{
	IOS;
	int n;
	cin >> n;
	rep(i,1,n)
		cin >> a[i];
	int m;
	cin >> m;
	rep(i,1,m){
		int l,r;
		cin >> l >> r;
		s[i] = {l,r,i};
	}
	sort(s+1,s+m+1);
	Fenwick<int> f(n);
	int r = 0;
	rep(i,1,m){
		while(r<s[i].r){
			++r;
			f.add(r,1);
			if(p[a[r]])
				f.add(p[a[r]],-1);
			p[a[r]] = r;
		}
		ans[s[i].id] = f.sum(s[i].l,s[i].r);
	}
	
	rep(i,1,m)
		cout << ans[i] << endl;
	
	return 0;
}

```

#### 多维树状数组 

二维树状数组：单点修改，区间查询，差分也是类似

实际上，我们在进行单点操作的时候，考虑的是修改这个位置后有多少位置会被影响到。显然，我们可以通过`i += i & -i`的方式，逆推原本位置被树状数组所管理的区间内。对于二维树状数组，我们实际上进行的也是一模一样的操作。但是这次不同，如果一维树状数组维护的是一个一维的数列，那么二维树状数组就是维护了一个一个二维的矩阵了。

我们现在考虑的是这个位置修改后，会影响到几个矩阵内的值。当然，上面已经提到过，二维树状数组其实是一个树状数组套树状数组，也就是每个节点都是一个树状数组，因此，我们在进行修改操作的时候，对于第一维的树状数组，我们要考虑修改这个位置的树状数组会影响到多少个位置的树状数组，进入到第二维时考虑的就是这个位置修改后会影响到多少个位置。可以发现，这样的操作后其实就是修改了一个一个的小矩形了，总的单次修改的时间复杂度为  $O(log(n)log(m))$。

时间复杂度是 $log(n)*log(m)$ 的，也就是是个双 $log$ 的

```c++
const int N = 5010;

ll tr[N][N];
int n,m;

inline int lowbit(int x)
{
	return x&(-x);
}

void add(int x,int y,int d)
{
	for(int i=x;i<=n;i+=lowbit(i)){
		for(int j=y;j<=m;j+=lowbit(j))
			tr[i][j] += d;
	}
}

ll query(int x,int y)
{
	ll res = 0;
	for(int i=x;i;i-=lowbit(i)){
		for(int j=y;j;j-=lowbit(j))
			res += tr[i][j];
	}
	return res;
}

ll query(int x1,int y1,int x2,int y2)
{
	ll ans = query(x2,y2)-query(x1-1,y2)-query(x2,y1-1)+query(x1-1,y1-1);
	return ans;
}

int main()
{
	IOS;
	cin >> n >> m;
	int op;
	while(cin >> op){
		if(op == 1){
			int x,y,d;
			cin >> x >> y >> d;
			add(x,y,d);
		}
		else{
			int x1,y1,x2,y2;
			cin >> x1 >> y1 >> x2 >> y2;
			ll ans = query(x2,y2)-query(x1-1,y2)-query(x2,y1-1)+query(x1-1,y1-1);
			cout << ans << endl;
		}
	}
	return 0;
}

```

### 平衡树

#### splay

#### treap

```c++
const int N = 1e5+10;

struct node{
	int l,r;
	int key,val;
	int cnt,size;
}tr[N];

int n,root,idx;

void pushup(int u)
{
	tr[u].size=tr[tr[u].l].size+tr[tr[u].r].size+tr[u].cnt;
}

int get_node(int key)
{
	tr[++idx].key = key;
	tr[idx].val = rand();
	tr[idx].cnt = tr[idx].size = 1;
	return idx;
}

void zig(int &p) // 右旋
{
	int q=tr[p].l;
	tr[p].l=tr[q].r,tr[q].r=p,p=q;
	pushup(tr[p].r);
	pushup(p);
}

void zag(int &p) // 左旋
{
	int q=tr[p].r;
	tr[p].r=tr[q].l,tr[q].l=p,p=q;
	pushup(tr[p].l);
	pushup(p);
}

void build()
{
	get_node(-inf);
	get_node(inf);
	root = 1,tr[root].r = 2;
	pushup(root);
	if(tr[1].val<tr[2].val) zag(root);
}

void insert(int &p,int key)
{
	if(!p) p = get_node(key);
	else if(tr[p].key == key) tr[p].cnt++;
	else if(tr[p].key > key){
		insert(tr[p].l,key);
		if(tr[tr[p].l].val > tr[p].val) zig(p);
	}
	else{
		insert(tr[p].r,key);
		if(tr[tr[p].r].val > tr[p].val) zag(p);
	}
	pushup(p);
}

void remove(int &p,int key)
{
	if(!p) return ;
	else if(tr[p].key == key){
		if(tr[p].cnt > 1) tr[p].cnt--;
		else if(tr[p].l || tr[p].r){
			if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val){
				zig(p);
				remove(tr[p].r,key);
			}
			else{
				zag(p);
				remove(tr[p].l,key);
			}
		} 
		else p = 0;
	}
	else if(tr[p].key > key) remove(tr[p].l,key);
	else remove(tr[p].r,key);

	pushup(p);
}

int get_rank_by_key(int p,int key)
{
	if(!p) return 1;
	if(tr[p].key == key) return tr[tr[p].l].size+1;
	else if(tr[p].key>key) return get_rank_by_key(tr[p].l,key);
	return tr[tr[p].l].size+tr[p].cnt+get_rank_by_key(tr[p].r,key);
}

int get_key_by_rank(int p,int rank)
{
	if(!p) return inf;
	if(tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l,rank);
	if(tr[tr[p].l].size+tr[p].cnt >= rank) return tr[p].key;
	return get_key_by_rank(tr[p].r,rank-tr[tr[p].l].size-tr[p].cnt);
}

int get_prev(int p,int key)
{
	if(!p) return -inf;
	if(tr[p].key >= key) return get_prev(tr[p].l,key);
	return max(tr[p].key,get_prev(tr[p].r,key));
}

int get_next(int p,int key)
{
	if(!p) return inf;
	if(tr[p].key<=key) return get_next(tr[p].r,key);
	return min(tr[p].key,get_next(tr[p].l,key));
}

int main()
{
	IOS;
	build();

	cin >> n;
	while(n--){
		int op,x;
		cin >> op >> x;
		if(op == 1) insert(root,x);
		else if(op == 2) remove(root,x);
		else if(op == 3) cout << get_rank_by_key(root,x)-1 << endl;
		else if(op == 4) cout << get_key_by_rank(root,x+1) << endl;
		else if(op == 5) cout << get_prev(root,x) << endl;
		else cout << get_next(root,x) << endl;
	}

	return 0;
}
```

#### fhqtreap

#### 可持久化平衡树

#### 其他

##### 替罪羊树

##### AVL

##### SBT

##### 红黑树

### 树套树

#### 线段树套线段树

#### 线段树套平衡树

### 树链部分

#### 重链剖分

```c++
/*
id表示当前结点在重新编完的序里面序号
nw表示重新编完序的权值
top表示重链的头 也就是深度最低的那一个
*/

const int N = 1e5+10,M = N*2; 

int n,m;
int w[N],h[N],e[M],ne[M],idx;
int id[N],nw[N],cnt;
int dep[N],sz[N],top[N],fa[N],son[N];

struct node{
	int l,r;
	ll add,sum;
}tr[N*4];

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void dfs1(int u,int father,int depth)
{
	dep[u] = depth;
	fa[u] = father;
	sz[u] = 1;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == father)
			continue;
		dfs1(j,u,depth+1);
		sz[u] += sz[j];
		if(sz[son[u]] < sz[j])
			son[u] = j;
	}
}

void dfs2(int u,int t)
{
	id[u] = ++cnt;
	nw[cnt] = w[u];
	top[u] = t;
	if(!son[u])
		return ;
	dfs2(son[u],t);
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == fa[u] || j == son[u])
			continue;
		dfs2(j,j);
	}
}

void pushup(int u)
{
	tr[u].sum = tr[u<<1].sum+tr[u<<1|1].sum;
}

void pushdown(int u)
{
	if(tr[u].add){
		tr[u<<1].add += tr[u].add;
		tr[u<<1|1].add += tr[u].add;
		tr[u<<1].sum += tr[u].add*(tr[u<<1].r-tr[u<<1].l+1);
		tr[u<<1|1].sum += tr[u].add*(tr[u<<1|1].r-tr[u<<1|1].l+1);
		tr[u].add = 0;
	}
}

void build(int u,int l,int r)
{
	tr[u].l = l;
	tr[u].r = r;
	tr[u].add = 0;
	if(l == r){
		tr[u].sum = nw[l];
		return ;
	}
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	pushup(u);
}

void update(int u,int l,int r,ll k)
{
	if(tr[u].l >= l && tr[u].r <= r){
		tr[u].add += k;
		tr[u].sum += k*(tr[u].r-tr[u].l+1);
		return ;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid)
		update(u<<1,l,r,k);
	if(r>mid)
		update(u<<1|1,l,r,k);
	pushup(u);
}

ll query(int u,int l,int r)
{
	if(tr[u].l >= l && tr[u].r <= r)
		return tr[u].sum;
	pushdown(u);
	ll ans=0;
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid)
		ans += query(u<<1,l,r);
	if(r>mid)
		ans += query(u<<1|1,l,r);
	return ans;
}

void update_path(int u,int v,ll k)
{
	while(top[u] != top[v]){
		if(dep[top[u]] < dep[top[v]])
			swap(u,v);
		update(1,id[top[u]],id[u],k);
		u = fa[top[u]];
	}
	if(dep[u] < dep[v])
		swap(u,v);
	update(1,id[v],id[u],k);
}

void update_tree(int u,ll k)
{
	update(1,id[u],id[u]+sz[u]-1,k);
}

ll query_path(int u,int v)
{
	ll ans=0;
	while(top[u] != top[v]){
		if(dep[top[u]] < dep[top[v]])
			swap(u,v);
		ans += query(1,id[top[u]],id[u]);
		u = fa[top[u]];
	}
	if(dep[u] < dep[v])
		swap(u,v);
	ans += query(1,id[v],id[u]);
	return ans;
}

ll query_tree(int u)
{
	return query(1,id[u],id[u]+sz[u]-1);
}

int main()
{
	IOS;
	cin >> n;
	rep(i,1,n)
		cin >> w[i];
	memset(h,-1,sizeof h);
	rep(i,1,n-1){
		int a,b;
		cin >> a >> b;
		add(a,b);
		add(b,a);
	}
	
	dfs1(1,-1,1);
	dfs2(1,1);
	build(1,1,n);
	
	cin >> m;
	while(m--){
		int t,u,v,k;
		cin >> t >> u;
		if(t == 1){
			cin >> v >> k;
			update_path(u,v,k);
		}
		else if(t == 2){
			cin >> k;
			update_tree(u,k);
		}
		else if(t == 3){
			cin >> v;
			cout << query_path(u,v) << endl;
		}
		else
			cout << query_tree(u) << endl;
	}

	return 0;
}
```

#### 长链剖分

### 笛卡尔树

### 基环树

单向边找环

```c++
const int N = 1e6+10;

int w[N],n;
int h[N],e[N],ne[N],idx;
ll dp[N][2];
bool vis[N];
int r1,r2;

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void find(int u,int root)
{
	vis[u] = true;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == root){
			r1 = u;
			r2 = j;
			return ;
		}
		if(vis[j])
			continue;
		find(j,root);
	}
}

ll dfs(int u,int root)
{
	dp[u][0] = 0;
	dp[u][1] = w[u];
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j == root)
			continue;
		dfs(j,root);
		dp[u][0] += max(dp[j][0],dp[j][1]);
		dp[u][1] += dp[j][0];
	}
	
	return dp[u][0]; 
}

int main()
{
	IOS;
	cin >> n;
	int x;
	memset(h,-1,sizeof h);
	rep(i,1,n){
		cin >> w[i] >> x;
		add(x,i);
	}
	
	ll sum = 0;
	rep(i,1,n){
		r1 = r2 = 0;
		find(i,i);
		if(r1){
			ll ans1 = dfs(r1,r1);
			ll ans2 = dfs(r2,r2);
			sum += max(ans1,ans2);
		}
	}
	
	cout << sum << endl;

	return 0;
}
```

枚举断边进行计算

```c++
const int N = 5010;

int n,m;
vector<int> v[N];
vector<int> path(N,N);
PII edge[N];
bool vis[N];
int du,dv,cnt,better;

bool dfs(int u)
{
	if(!better){
		if(u>path[cnt])
			return true;
		if(u<path[cnt])
			better = -1;
	}
	vis[u] = true;
	path[cnt++] = u;
	for(auto j:v[u]){
		if(vis[j])
			continue;
		if(u==du && j==dv)
			continue;
		if(u==dv && j==du)
			continue;
		if(dfs(j))
			return true;
	}
	return false;
}

int main()
{
	IOS;
	cin >> n >> m;
	rep(i,1,m){
		int a,b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
		edge[i] = {a,b};
	}
	
	rep(i,1,n)
		sort(v[i].begin(),v[i].end());
	if(m == n-1)
		dfs(1);
	else{
		rep(i,1,m){
			du = edge[i].fi;
			dv = edge[i].se;
			memset(vis,0,sizeof vis);
			cnt = better = 0;
			dfs(1);
		}
	}
	
	for(int i=0;i<n;i++)
		cout << path[i] << " ";
	cout << endl;

	return 0;
}
```

### 树的启发式合并

```c++
启发式合并

类似并查集的按秩合并
   -  -
  | ↓| ↓ 
  o  o  o  o  o
暴力合并:
    1+2+3+...n-1 
    O(n^2)   每次合并都遍历一遍之前所有的点
 -> O(nlogn) 每次把元素所在的集合进行合并
             则每次合并之后所在集合元素个数 >= 原个数 * 2
             则每个元素最多合并logn次
```

普通启发式合并代码：

```c++
const int N = 1e5+10,M = 1e6+10; 

int h[M],e[M],ne[M],idx;
int sz[M],p[M];
int color[N];
ll ans;
 
void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
	sz[a]++;
}

void merge(int &x,int &y)
{
	if(x == y)
		return ;
	if(sz[x] > sz[y])
		swap(x,y);
	for(int i=h[x];i!=-1;i=ne[i]){
		int j=e[i];
		ans -= (color[j-1] == y) + (color[j+1] == y);
	}
	for(int i=h[x];i!=-1;i=ne[i]){
		int j=e[i];
		color[j] = y;
		if(ne[i] == -1){
			ne[i] = h[y];
			h[y] = h[x];
			break;
		}
	}
	h[x] = -1;
	sz[y] += sz[x];
	sz[x] = 0;
}
 
int main()
{
	IOS;
	int n,m;
	cin >> n >> m;
	memset(h,-1,sizeof h);
	rep(i,1,n){
		cin >> color[i];
		ans += (color[i] != color[i-1]);
		add(color[i],i);
	}
	
	for(int i=0;i<M;i++)
		p[i] = i;
	
	while(m--){
		int op;
		cin >> op;
		if(op == 2)
			cout << ans << endl;
		else{
			int x,y;
			cin >> x >> y;
			merge(p[x],p[y]);
		}
	} 

	return 0;
}

```

$Dsu\;on\;tree$

```c++
const int N = 1e5+10,M = N*2;

int n;
int h[N],e[M],ne[M],idx;
int color[N],cnt[N],sz[N],son[N];
ll ans[N],sum;
int mx;

void add(int a,int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void dfs_son(int u,int fa)
{
	sz[u] = 1;
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j == fa)
			continue;
		dfs_son(j,u);
		sz[u] += sz[j];
		if(sz[j]>sz[son[u]])
			son[u] = j;
	}
}

void update(int u,int fa,int sign,int pson)
{
	int c = color[u];
    cnt[c] += sign;
    if (cnt[c] > mx) 
		mx = cnt[c], sum = c;
    else if (cnt[c] == mx) 
		sum += c;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa || j == pson) 
			continue;
        update(j, u, sign, pson);
    }
}

void dfs(int u,int fa,int op)
{
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j==fa || j==son[u])
			continue;
		dfs(j,u,0);
	}
	
	if(son[u])
		dfs(son[u],u,1);
	update(u,fa,1,son[u]);
	ans[u] = sum;
	if(!op)
		update(u,fa,-1,0),sum = mx = 0;
}

int main()
{
	IOS;
	cin >> n;
	rep(i,1,n)
		cin >> color[i];
	memset(h,-1,sizeof h);
	rep(i,1,n-1){
		int a,b;
		cin >> a >> b;
		add(a,b);
		add(b,a);
	}
	dfs_son(1,-1);
	dfs(1,-1,1);
	
	rep(i,1,n)
		cout << ans[i] << " ";
	cout << endl;

	return 0;
}

```

### LCT

$a_k<a_{k+1}\;\; a_n = sqrt(1+a_n-1)\;\;a_{n-1} = sqrt(1+a_{n-2})$

### 虚树

构造过程：二次排序加 $LCA$ 连边

非常直观的一个方法是：

- 将关键点按 $DFS$ 序排序；
- 遍历一遍，任意两个相邻的关键点求一下 $LCA$，并且判重；
- 然后根据原树中的祖先后代关系建树。

具体实现上，在 **关键点序列** 上，枚举 **相邻的两个数**，两两求得 $LCA$ 并且加入序列 $A$ 中。

因为 $DFS$ 序的性质，此时的序列 $A$ 已经包含了 **虚树中的所有点**，但是可能有重复。

所以我们把序列 $A$ 按照 $dfn$序 **从小到大排序并去重**。

最后，在序列 $A$ 上，枚举 **相邻** 的两个 **点编号** $x,y$，求得它们的 $LCA$ 并且连接 $LCA,y$ 虚树就构造完成了。

#### 无边权代码例题：

```c++
const int N = 1e5+10;
const int bit = 20;
vector<int> v1[N],v2[N];
int n,m,q,len;
int depth[N],h[N],dfn[N],idx;
int fa[N][bit+1];
int a[N*2],ans,sz[N];

int lca(int a,int b)
{
	if(depth[a]<depth[b])
		swap(a,b);
	for(int k=bit-1;k>=0;k--){
		if(depth[fa[a][k]] >= depth[b])
			a = fa[a][k];
	}
	if(a == b) return a;
	
	for(int k=bit-1;k>=0;k--){
		if(fa[a][k] != fa[b][k]){
			a = fa[a][k];
			b = fa[b][k];
		}
	}
	
	return fa[a][0];
}

void dfs(int u,int father)
{
	dfn[u] = ++idx;
	for(auto x:v1[u]){
		if(x == father) continue;
		fa[x][0] = u;
		for(int i=1;i<bit;i++)
			fa[x][i] = fa[fa[x][i-1]][i-1];
		depth[x] = depth[u]+1;
		dfs(x,u);
	}
}

bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}

void build_tree()
{
	sort(h+1,h+m+1,cmp);
	len = 0;
	a[++len] = 1;
	for(int i=1;i<m;i++){
		a[++len] = h[i];
		a[++len] = lca(h[i],h[i+1]);
	}
	a[++len] = h[m];
	sort(a+1,a+len+1,cmp);
	len = unique(a+1,a+len+1)-a-1;
	for(int i=1,lc;i<len;i++){
		lc = lca(a[i],a[i+1]);
		v2[lc].pb(a[i+1]);
	}
}

void dfs1(int u)
{
	if(sz[u]){
		for(auto x:v2[u]){
			dfs1(x);
			if(sz[x]){
				ans++;
				sz[x] = 0;
			}
		}
	}
	else{
		for(auto x:v2[u]){
			dfs1(x);
			sz[u] += sz[x];
			sz[x] = 0;
		}
		if(sz[u]>1){
			ans++;
			sz[u] = 0;
		}
	}
}

int main()
{
	IOS;
	cin >> n;
	rep(i,2,n){
		int a,b;
		cin >> a >> b;
		v1[a].pb(b);
		v1[b].pb(a); 
	}
	
	depth[1] = 1;
	dfs(1,-1);
	cin >> q;
	while(q--){
		cin >> m;
		rep(i,1,m){
			cin >> h[i];
			sz[h[i]] = 1;
		}
		bool f1 = false;
		rep(i,1,m){
			if(h[i]!=1 && sz[fa[h[i]][0]]==1){
				f1 = true;
				break;
			}
		}
		if(f1){
			cout << -1 << endl;
			rep(i,1,m)
				sz[h[i]] = 0;
			continue;
		}
		
		build_tree();
		ans = 0;
		dfs1(1);
		cout << ans << endl;
		rep(i,1,len){
			sz[a[i]] = 0;
			v2[a[i]].clear();
		}
	}
	

	return 0;
}

```

有边权代码：注意边权，本次例题维护的是 $LCA,y$ 这条路径上最小的边权，不同的题目维护的边权不一样。

```c++
const int N = 250010,M = N*2;

const int bit = 20;
vector<PII> v1[N],v2[N];
int n,m,len;
int depth[N],h[N],dfn[N],idx;
int fa[N][bit+1];
ll mn[N][bit+1];
int a[M];
ll dp[N],d[N];
bool st[N];

int lca(int a,int b)
{
	if(depth[a]<depth[b]) swap(a,b);
	for(int k=bit-1;k>=0;k--){
		if(depth[fa[a][k]] >= depth[b])
			a = fa[a][k];
	}
	if(a == b) return a;
	for(int k=bit-1;k>=0;k--){
		if(fa[a][k] != fa[b][k]){
			a = fa[a][k];
			b = fa[b][k];
		}
	}
	return fa[a][0];
}

void dfs(int u,int father)
{
	dfn[u] = ++idx;
	for(auto [x,w]:v1[u]){
		if(x == father) continue;
		depth[x] = depth[u]+1;
		d[x] = d[u]+w;
		fa[x][0] = u;
		mn[x][0] = w;
		for(int i=1;i<bit;i++){
			fa[x][i] = fa[fa[x][i-1]][i-1];
			mn[x][i] = min(mn[x][i-1],mn[fa[x][i-1]][i-1]);
		}
		dfs(x,u);
	}
}

bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}

void build_tree()
{
	sort(h+1,h+m+1,cmp);
	len = 0;
	a[++len] = 1;
	for(int i=1;i<m;i++){
		a[++len] = h[i];
		a[++len] = lca(h[i],h[i+1]);
	}
	a[++len] = h[m];
	sort(a+1,a+len+1,cmp);
	len = unique(a+1,a+len+1)-(a+1);
	for(int i=1,lc;i<len;i++){
		lc = lca(a[i],a[i+1]);
		int pos = a[i+1];
		ll dist = 0;
		if(pos == lc) dist = 0;
		else{
			dist = inf;
			for(int k=bit-1;k>=0;k--){
				if(depth[fa[pos][k]] >= depth[lc]){
					dist = min(dist,mn[pos][k]);
					pos = fa[pos][k];
				}
			}
		}
		v2[lc].pb({a[i+1],dist});
	}
}

void dfs1(int u)
{
	dp[u] = 0;
	for(auto [x,w]:v2[u]){
		dfs1(x);
		if(st[x]) dp[u] += w;
		else dp[u] += min(dp[x],w);
	}
	v2[u].clear();
}

void solve()
{
	cin >> n;
	rep(i,2,n){
		int a,b,c;
		cin >> a >> b >> c; 
		v1[a].pb({b,c});
		v1[b].pb({a,c});
	}
	depth[1] = 1;
	d[1] = 0;
	dfs(1,-1);
	
	int q;
	cin >> q;
	while(q--){
		cin >> m;
		rep(i,1,m){
			cin >> h[i];
			st[h[i]] = true;
		}
		
		build_tree();
		dfs1(1);
		cout << dp[1] << endl;
		rep(i,1,m)
			st[h[i]] = false;
	}
}

int main()
{
	IOS;
	int t;
	t = 1; 
	while(t--)
		solve();

	return 0;
}

```

### KD树

### 树的哈希

例题：问树中有多少个互不同构的子树，这是对有根树进行操作的

复杂度：$O(nlog(n))$ 其中 $log$ 是 $set$ 用来判重所带来的复杂度

```c++
#include <chrono>
#include <random>

typedef unsigned long long ull;

// 使用随机数来作为mask 记得头文件
const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

const int N = 1e6+10;

int n;
ull hash1[N];
vector<int> edge[N];
set<ull> trees;

ull shift(ull x)
{
	x ^= mask;
	x ^= x<<13;
	x ^= x>>7;
	x ^= x<<17;
	x ^= mask;
	return x;
}

void get_hash(int u,int p)
{
	hash1[u] = 1;
	for(int i:edge[u]){
		if(i == p)
			continue;
		get_hash(i,u);
		hash1[u] += shift(hash1[i]);
	}
	trees.insert(hash1[u]);
}

int main()
{
	IOS;
	cin >> n;
	rep(i,1,n-1){
		int a,b;
		cin >> a >> b;
		edge[a].pb(b);
		edge[b].pb(a);
	}
	
	get_hash(1,0);
	cout << trees.size() << endl;

	return 0;
}

```

模板题：判断多少个树是同构的

```c++
typedef unsigned long long ull;

const int N = 60,M = 998244353;

const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

ull shift(ull x) {
  x ^= mask;
  x ^= x << 13;
  x ^= x >> 7;
  x ^= x << 17;
  x ^= mask;
  return x;
}

vector<int> e[N];
ull root[N],sub[N];
map<ull,int> trees;

void get_sub(int u)
{
	sub[u] = 1;
	for(int i:e[u]){
		get_sub(i);
		sub[u] += shift(sub[i]);
	}	
} 

void get_root(int x)
{
	for(int i:e[x]){
		root[i] = sub[i]+shift(root[x]-shift(sub[i]));
		get_root(i);
	}
}

int main()
{
	IOS;
	int m;
	cin >> m;
	rep(j,1,m){
		int n,rt=0;
		cin >> n;
		rep(i,1,n){
			int x;
			cin >> x;
			if(x)
				e[x].pb(i);
			else
				rt = i;
		}
		get_sub(rt);
		root[rt] = sub[rt];
		get_root(rt);
		ull hash = 1;
		rep(i,1,n)
			hash += shift(root[i]);
		if(!trees.count(hash))
			trees[hash] = j;
		cout << trees[hash] << endl;
		rep(i,1,n)
			e[i].clear();
	}

	return 0;
}
```

### 树套表

### 划分树

### 析合树

### 珂朵莉树

别名：Chtholly Tree 也叫 ODT (Old Driver Tree).

用处：在保证出现数据推平也就是将一段区间全部赋值为一个数的操作 以及 数据随机的情况下可以使用 珂朵莉树。

**split**

​	split它用于将原本包含点 $x$ 的区间（设为 $[l,r]$ ）分裂为两个区间$[l,x)$ 和 $[x,r]$ 并返回指向后者的迭代器。

代码：

```c++
struct Node{
	int l,r;
	mutable ll v;
	Node(ll l,ll r = 0,ll v = 0):l(l),r(r),v(v){}
	bool operator<(const Node &a) const{
		return l<a.l;
	}
};
set<Node> s;

set<Node>::iterator split(int pos)
{
	set<Node>::iterator it = s.lower_bound(Node(pos));
	if(it != s.end() && it->l == pos) return it;
	it--;
	if(it->r < pos) return s.end();
	int l=it->l;
	int r=it->r;
	ll v = it->v;
	s.erase(it);
	s.insert(Node(l,pos-1,v));
	return s.insert(Node(pos,r,v)).first;
}

void assign(int l,int r,ll x)
{
	set<Node>::iterator itr = split(r+1),itl = split(l);
	s.erase(itl,itr);
	s.insert(Node(l,r,x));
}

void add(int l,int r,ll x)
{
	set<Node>::iterator itr = split(r+1),itl = split(l);
	for(auto it = itl;it != itr;++it)
		it->v += x;
}

ll calc_sum(int l,int r)
{
	set<Node>::iterator itr = split(r+1),itl = split(l);
	ll ans = 0;
	for(auto it = itl;it != itr;++it)
		ans = (ans+1ll*it->v*(it->r-it->l+1)%mod)%mod;
	return ans;
}

void copy(int l1,int r1,int l2,int r2)
{
	if(l1>l2){
		swap(l1,l2);
		swap(r1,r2);
	}
	int len1=0,len2=0;
	set<Node>::iterator itr = split(r1+1),itl = split(l1);
	for(auto it=itl;it!=itr;it++){
		a[++len1].v = it->v;
		a[len1].l = it->l;
		a[len1].r = it->r;
	}
	itr = split(r2+1),itl = split(l2);
	for(auto it=itl;it!=itr;it++){
		b[++len2].v = it->v;
		b[len2].l = it->l;
		b[len2].r = it->r;
	}
	itr = split(r1+1),itl = split(l1);
	s.erase(itl,itr);
	itr = split(r2+1),itl = split(l2);
	s.erase(itl,itr);
	rep(i,1,len1) 
		s.insert(Node(a[i].l-l1+l2,a[i].r-l1+l2,a[i].v));
	rep(i,1,len2)
		s.insert(Node(b[i].l-l2+l1,b[i].r-l2+l1,b[i].v));
}

void move(int l1,int r1,int l2,int r2)
{
	int len = 0;
	set<Node>::iterator itr = split(r1+1),itl = split(l1);
	for(auto it = itl;it != itr;++it){
		a[++len].v = it->v;
		a[len].l = it->l;
		a[len].r = it->r;
	}
	itr = split(r2+1),itl = split(l2);
	s.erase(itl,itr);
	for(int i=1;i<=len;i++)
		s.insert(Node(a[i].l-l1+l2,a[i].r-l1+l2,a[i].v));
}

void reverse(int l,int r)
{
	if(l>r) swap(l,r);
	int len = 0;
	set<Node>::iterator itr = split(r+1),itl = split(l);
	for(auto it = itl;it != itr;++it){
		a[++len].v = it->v;
		a[len].l = it->l;
		a[len].r = it->r;
	}
	s.erase(itl,itr);
	for(int i=1;i<=len;i++)
		s.insert(Node(r+l-a[i].r,r+l-a[i].l,a[i].v));
}

s.insert(Node(n+1,n+1,666));
```

### 左偏树

![左偏树1](D:\桌面\template\png\左偏树1.png)

![左偏树2](D:\桌面\template\png\左偏树2.png)

![左偏树3](D:\桌面\template\png\左偏树3.png)

![左偏树4](D:\桌面\template\png\左偏树4.png)

例题：支持两种操作，一种是合并两个堆，一种是删除第 x 个元素所在堆的元素。

易错：在删除节点时，要对三个 fa 数组进行重新赋值，而合并时只需要对两个 fa 数组重新赋值

```c++
const int N = 1e6+10;

int v[N],lc[N],rc[N],dis[N];
int fa[N];

int find(int x)
{
	if(fa[x] != x) fa[x] = find(fa[x]);
	return fa[x]; 
}

int merge(int x,int y)
{
	if(!x || !y) return x|y;
	if(v[x]==v[y]?x>y:v[x]>v[y])
		swap(x,y);
	rc[x] = merge(rc[x],y);
	if(dis[lc[x]]<dis[rc[x]]) swap(lc[x],rc[x]);
	dis[x] = dis[rc[x]]+1;
	return x;
}

int main()
{
	IOS;
	int n,m;
	cin >> n >> m;
	rep(i,1,n)
		cin >> v[i];
	std::iota(fa+1,fa+n+1,1);
	dis[0] = -1;
	int op,x,y;
	while(m--){
		cin >> op;
		if(op == 1){
			int x,y;
			cin >> x >> y;
			if(v[x]==-1 || v[y]==-1) continue;
			x = find(x);
			y = find(y);
			if(x!=y) fa[x]=fa[y]=merge(x,y);
		}
		else{
			cin >> x;
			if(v[x] == -1){
				cout << -1 << endl;
				continue;
			}
			x = find(x);
			cout << v[x] << endl;
			v[x] = -1;
			fa[lc[x]] = fa[rc[x]] = fa[x] = merge(lc[x],rc[x]);
		}
	}
	return 0;
}
```

## 并查集

### 模板

```c++
struct DSU {
    std::vector<int> f,sz;
    DSU(){}
    DSU(int n){
        init(n);
    }
    
    void init(int n){
        f.resize(n+1);
        std::iota(f.begin(),f.end(),0);
        sz.assign(n+1,1);
    }
    
    int find(int x){
        while(x != f[x])
            x = f[x] = f[f[x]];
        return x;
    }
    
    bool same(int x,int y){
        return find(x) == find(y);
    }
    
    bool merge(int x,int y){
        x = find(x);
        y = find(y);
        if (x == y) return false;
        sz[x] += sz[y];
        f[y] = x;
        return true;
    }
    int size(int x){
        return sz[find(x)];
    }
};
```

技巧：

​	在每次合并一个区间的操作情况下，可以考虑 ne[i] 表示与 i 不在同一个集合的位置，每次跳 ne[i] 即可。

```c++
const int N = 2e5+10;

int p[N],ne[N];
int find(int x)
{
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}

int main()
{
	IOS;
	int n,q;
	cin >> n >> q;
	rep(i,1,n){
		p[i] = i;
		ne[i] = i+1;
	}
	p[n+1] = n+1;

	while(q--){
		int op,x,y;
		cin >> op >> x >> y;
		if(op == 1) p[find(x)] = find(y);
		else if(op == 2){
            // 合并一个区间
			int to;
			for(int i=ne[x];i<=y;i=to){
				p[find(i)] = find(i-1);
				to = ne[i];
				ne[i] = ne[y];
			}
		}
		else{
			if(find(x) == find(y)) cout << "YES" << endl;
			else cout << "NO" << endl;
		}
	}

	return 0;
}
```

### 带权并查集

```c++
const int N = 30010;
int p[N],psize[N];
int d[N];

int find(int x)
{
	if(p[x] != x){
		int root = find(p[x]);
		d[x] += d[p[x]];
		p[x] = root;
	}
	return p[x];
}

int main()
{
	IOS;
	int t;
	cin >> t;
	for(int i=1;i<N-5;i++){
		p[i] = i;
		psize[i] = 1;
	}
	while(t--){
		string op;
		int a,b;
		cin >> op >> a >> b;
		if(op == "M"){
			int pa=find(a);
			int pb=find(b);
			if(pa != pb){
				d[pa] = psize[pb];
				psize[pb] += psize[pa];
				p[pa] = pb;
			}
		}
		else{
			int pa=find(a);
			int pb=find(b);
			if(pa == pb){
				int ans = abs(d[a]-d[b])-1;
				cout << max(0,ans) << endl;
			}
			else
				cout << -1 << endl; 
		}
	}

	return 0;
}

```

扩展域并查集

```c++
const int N = 40010,Base = N/2;
unordered_map<int,int> S;
int idx;
int p[N];

int find(int x)
{
	if(p[x] != x)
		p[x] = find(p[x]);
	return p[x];
}

int get(int x)
{
	if(S.count(x) == 0)
		S[x] = ++idx;
	return S[x];
}

int main()
{
	IOS;
	int n,m;
	cin >> n >> m;
	int res = m;
	for(int i=1;i<N-5;i++)
		p[i] = i;
	rep(i,1,m){
		int l,r;
		string op;
		cin >> l >> r >> op;
		if(op == "even"){
			int a=get(l-1),b=get(r);
			if(find(a+Base) == find(b)){
				res = i-1;
				break;
			}
			p[find(a)] = find(b);
			p[find(a+Base)] = find(b+Base);
		}
		else{
			int a=get(l-1),b=get(r);
			if(find(a) == find(b)){
				res = i-1;
				break;
			}
			p[find(a+Base)] = find(b);
			p[find(a)] = find(b+Base);
		}
	}
	
	cout << res << endl; 

	return 0;
}

```

### 可持久化并查集

## 分块

### 莫队

#### 普通莫队

##### 形式

假设 $n=m$，那么对于序列上的区间询问问题，如果从 $[l,r]$ 的答案能够 $O(1)$ 扩展到 $[l-1,r],[l+1,r],[l,r+1],[l,r-1]$(即与 $[l,r] $ 相邻的区间）的答案，那么可以在 $O(n\sqrt{n})$的复杂度内求出所有询问的答案。

##### 解释

离线后排序，顺序处理每个询问，暴力从上一个区间的答案转移到下一个区间答案（一步一步移动即可）。

##### 排序方法

对于区间 $[l,r]$, 以 $l$ 所在块的编号为第一关键字, $r$ 为第二关键字从小到大排序。

**复杂度分析：**

​	莫队的复杂度分析主要是分析左右指针的移动次数，对于右指针来说 最坏情况是从 $1$ 到 $n$ ,而每个块最多只有一次因此是 $O(n\sqrt{n})$.对于左指针来说，要么在块内来回移动，要么在块间移动，对于前者最多移动 $\sqrt{n}$ 次，对于后者则最多遍历到 $n$ ,复杂度是 $O(n\sqrt{n})$ 级别的。莫队最重要的是需要控制块的大小，如果分块大小不合适的话会退化到 $O(nm)$ 级别的。而分析块的大小需要判断左右指针移动的次数来确定块的大小。

普通莫队例题：

​	维护区间里面不同数的个数。

```c++
const int N = 1e6+10;

int a[50010],cnt[N];
int ans[N];
int len;
struct Query{
	int id,l,r;
}q[N];

int get(int x)
{
	return x/len;
}

bool cmp(Query &a,Query &b)
{
	int i=get(a.l),j=get(b.l);
	if(i != j) return i<j;
	if(i&1) return a.r<b.r;
	return a.r>b.r;
}

inline void add(int x,int &res)
{
	if(cnt[x] == 0) res++;
	cnt[x]++;
}

inline void del(int x,int &res)
{
	cnt[x]--;
	if(cnt[x] == 0) res--;
}

int main()
{
	int n;
	scanf("%d",&n);
	rep(i,1,n) scanf("%d",&a[i]);
	int m;
	scanf("%d",&m);
	rep(i,1,m){
		int l,r;
		scanf("%d%d",&l,&r);
		q[i] = {i,l,r};
	}
	len = max(1,(int)sqrt((double)n*n/m));
	
	sort(q+1,q+m+1,cmp);
	for(int k=1,i=0,j=1,res=0;k<=m;k++){
		auto [id,l,r] = q[k];
		while(i < r) add(a[++i],res);
		while(i > r) del(a[i--],res);
		while(j < l) del(a[j++],res);
		while(j > l) add(a[--j],res);
		ans[id] = res; 
	}
	rep(i,1,m)
		printf("%d\n",ans[i]);

	return 0;
}

```

### 链上分块

### 树上分块

## STL

### vector

相关函数：

```c++
vector<int> v(n); // 初始化长度为n的数组
vector<int> v(n,m); // 初始化长度为n的数组，其中值为m
a.size() // 返回a的实际长度 O(1)
a.empty() //判断是否为空 O(1)
a.clear() //情况 O(n)
a.begin() a.end()  // 迭代器 sort里面会用
front() //第一个元素 
back() //最后一个元素
push_back() // 插到尾部
pop_back() // 删除最后一个元素
支持比较 == != < <= > >= //是按字典序进行比较的
```

### queue

相关函数：

```c++
queue<int> q;
q.size() // 容器大小
q.empty() // 判断是否为空
q.push() // 插入队列尾部
q.pop() // 出队 删除队头
q.front() // 队内的第一个元素
q.back() // 队列最后一个元素  以上复杂度均为O(1)
```

### priority_queue

相关函数：

```c++
push(); // 插入堆 O(log(n))
pop(); // 从堆顶删除 O(log(n))
top(); //查询堆顶元素 O(1)

/*
自定义类型必须重载小于号，如果需要小根堆就把小于号当大于号重载
*/
```

### deque

相关函数：

```c++
[] //支持随机访问 O(1)
begin() end() //迭代器 O(1)
front() back() // 返回首尾元素 O(1)
push_back() // 从尾部入队 O(1)
pop_back() // 删除尾部 O(1)
push_front() // 从首部入队 O(1)
pop_front() // 删除首部 O(1)
clear() // 清空 O(n)
```

### set/multiset

分为有序集合和有序多重集合，其中set为有序集合，multiset为有序多重集合，前者的元素不能重复，后者可以，如果以自定义数据类型为对象的话需要重载<号。

相关函数：

```c++
size() // O(1)
empty() // O(1)
clear()
begin() end() // 支持++ 和 -- 操作 两者复杂度均为O(log(n)) 
insert() // 插入一个数 O(log(n))
find() // 查找等于x的数，返回其迭代器
lower_bound()/upper_bound() // 查找>=x的元素中最小的一个，并返回指向该元素的迭代器 后者是>
erase() // 如果传入的是迭代器 就删除该迭代器对应的元素 O(log(n)) 如果是数就删除所有等于该数的元素 O(k+log(n))
count() // 返回集合中等于x的个数 O(k+log(n)) 其中k为元素的个数
prev()
next()
```

### map

map的键值必须定义小于号运算符

相关函数：

```
size()
empty()
clear()
begin()
end()
insert()
erase()
find()
[]
```

### bitset

相关函数：

```c++
a.any() //判断a数组里面是否存在1
a.none() //判断a数组里面是否全是0
a.count() //统计a数组里面1的个数
& | ^ ~ << >>
// 两个bitset之间可以运算
set(x); // 第x位置1
set();  // 全部置1
reset(x); // 第x位置0
reset(); // 全部置0
filp(x); // 第x位翻转
filp(); // 全部翻转

// 找出值为1的下标
for(int i=a._Find_first();i!=a.size();i=a._Find_next(i)){
		cout << i << endl;
}

// 流氓做法 找内存地址 将bitset转为ll数组 每64个为一个数
auto pa = (ll*)&a;
cout << pa[0] << endl;

// debug使用 显示数组的string表示
cout << a.to_string() << endl;
```

### pbds

### unordered_set

### unorderer_map